<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href=../src/css/initial.css rel=stylesheet type="text/css">
    <link href=../src/css/reset.css rel=stylesheet type="text/css">
    <link href=../src/css/colors.css rel=stylesheet type="text/css">
    <link href=../src/css/fonts.css rel=stylesheet type="text/css">
    <link href=../src/css/variables.css rel=stylesheet type="text/css">
    <script async rel=preload as="script" type="text/javascript" src="../wc-config.js"></script>
    <title>Tool Book... ðŸ™ˆðŸ™‰ðŸ™Š</title>
  </head>
  <body>
    <div>
      <h1>Tool Book... ðŸ™ˆðŸ™‰ðŸ™Š</h1>
      <view-tool-book></view-tool-book>
    </div>
    <script type=module>
      import {Shadow} from '../src/es/components/prototypes/Shadow.js'
      import jsonData from '../index.json' with {type: "json"}
      
      customElements.define('view-tool-book', class extends Shadow() {
        constructor (options = {}, ...args) {
          super({ importMetaUrl: import.meta.url, ...options }, ...args)

          this.selectComponentsChangeEventListener = async event => {
            const data = this.data?.find(data => data.origin === event.target.value)
            if (!data) return
            let example = await data.getExample()
            if (example.isError) {
              let result
              example = data.templates?.length
                ? (await Promise.all(data.templates.map(template => template.getExample()))).some(example => (result = example) && !example.isError) && result
                : '<h2>No Template Found!</h2>'
            }
            // TODO: fix path to images etc. same as in Template.html -> loadHTML -> fix relative links (test at image hotspot)
            this.sectionPreview.innerHTML = example?.text || example
            // custom element define
            const notDefined = Array.from(this.sectionPreview.querySelectorAll(':not(:defined)')).filter(node => !customElements.get(node.tagName.toLowerCase()))
            if (notDefined?.length) {
              if (document.body.hasAttribute(this.getAttribute('load-custom-elements') || 'load-custom-elements')) {
                this.dispatchEvent(new CustomEvent(this.getAttribute('load-custom-elements') || 'load-custom-elements', {
                  detail: {
                    nodes: notDefined
                  },
                  bubbles: true,
                  cancelable: true,
                  composed: true
                }))
              } else {
                console.error(
                  'There are :not(:defined) web components in the template. You must load through wc-config or manually:',
                  notDefined,
                  this
                )
              }
            }
          }
        }
        
        connectedCallback () {
          this.hidden = true
          const showPromises = []
          if (this.shouldRenderCSS()) showPromises.push(this.renderCSS())
          if (this.shouldRenderHTML()) showPromises.push(this.renderHTML())
          Promise.all(showPromises).then(() => {
            this.selectComponents.addEventListener('change', this.selectComponentsChangeEventListener)
            this.hidden = false
          })
        }

        disconnectedCallback () {
          this.selectComponents.removeEventListener('change', this.selectComponentsChangeEventListener)
        }
        
        /**
        * evaluates if a render is necessary
        *
        * @return {boolean}
        */
        shouldRenderCSS () {
          return !this.root.querySelector(`${this.cssSelector} > style[_css]`)
        }
        
        /**
        * evaluates if a render is necessary
        *
        * @return {boolean}
        */
        shouldRenderHTML () {
          return !this.sectionPreview
        }
        
        /**
        * renders the css
        *
        * @return {Promise<void>}
        */
        renderCSS () {
          this.css = /* css */`
            :host > section#preview {
              margin: 1em;
            }
          `
          return this.fetchTemplate()
        }

        /**
         * fetches the template
         *
         * @return {Promise<void>}
         */
        fetchTemplate () {
          /** @type {import("../../prototypes/Shadow.js").fetchCSSParams[]} */
          const styles = [
            {
              path: `${this.importMetaUrl}../src/css/reset.css`,
              namespace: false
            },
            {
              path: `${this.importMetaUrl}../src/css/style.css`, // apply namespace and fallback to allow overwriting on deeper level
              namespaceFallback: true
            }
          ]
          switch (this.getAttribute('namespace')) {
            default:
              return this.fetchCSS(styles, false)
          }
        }
          
        /**
        * renders the html
        *
        * @return {Promise<void>}
        */
        async renderHTML () {
          this.html = /* html */`
            <section id=controls>
              <select id=components name=components>
                <option value="">--Please choose a component--</option>
                ${(this.data = await this.fetchData()).reduce((acc, data) => {
                  if (data.isError) return acc
                  return /* html */`${acc}<option value="${data.origin}">${data.name}</option>`
                }, '')}
              </select>
            </section>
            <section id=preview>
            </section>
          `
        }
        
        async fetchData() {
          const responses = await Promise.all(Array.from(jsonData.fileUrls , function fetchUrl(url) {
            return fetch(url).then(async response => {
              if (response.status >= 200 && response.status <= 299) {
                let json = await response[url.includes('.json') ? 'json' : 'text']()
                if (typeof json === 'string') json = { text: json }
                json.origin = url
                json.name = url.replace(/(.*\/)([a-zA-Z]*).*$/, '$2')
                if (json.path) {
                  json.getExample = async () => await fetchUrl(`${json.path.replace(/(.*\/.*)\..*$/, '$1')}.html`)
                  json.getFile = async () => await fetchUrl(json.path)
                }
                if (json.templates) json.templates.forEach(template => {
                  template.getExample = async () => await fetchUrl(`${url.replace(/(.*\/)(.*)$/, '$1')}${template.path.replace(/(.*\/.*)\..*$/, '$1')}.html`)
                  template.getFile = async () => await fetchUrl(`${url.replace(/(.*\/)(.*)$/, '$1')}${template.path}`)
                })
                return json
              }
              throw new Error(response.statusText)
            }).catch(error => console.log(error = { isError: true, origin: url, name: url.replace(/(.*\/)([a-zA-Z]*).*$/, '$2'), error }) || error)
          }))
          return responses
        }

        get sectionControls () {
          return this.root.querySelector('section#controls')
        }

        get selectComponents () {
          return this.root.querySelector('select#components')
        }
        
        get sectionPreview () {
          return this.root.querySelector('section#preview')
        }
      })
    </script>
    <style>
      body {
        padding: 1em;
      }
    </style>
  </body>
</html>